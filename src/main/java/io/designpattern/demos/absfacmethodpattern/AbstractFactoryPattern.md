# 抽象工厂模式

> 引用自：[抽象工厂模式](http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/abstract_factory.html)

在工厂模式中，我们通常利用工厂，来生产属于同一个产品族而具有不同层级结构的产品。
如我们需要生产汽车，在汽车中情况又如下：
汽车->轿车、越野车、跑车->2.0排量汽车、2.0排量越野车、2.0排量汽
等一系列的继承关系。

而抽象工厂模式，则是工厂模式的升级版，该模式，旨在创建若干个有依赖关系的产品对象，这些产品，可属于不同的产品族，如生产汽车则有：

汽车->宝马汽车、奔驰汽车

发动机->宝马汽车发动机、奔驰汽车发动机

如此，汽车与发动机存在某些依赖关系，并且汽车与发动机属于不同的产品族，而宝马汽车、与宝马配件属于同一个产品族，利用抽象工厂，即可分别生产宝马汽车的同时，生产出宝马汽车所需要的配件，供宝马汽车使用。
并且抽象工厂模式，更加适用于，系统中不只有一个产品族，而同一产品族的不同对象需要在一起使用的情形。

该模式UML类图如下：
![抽象工厂模式](http://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg)

利用抽象工厂模式，优点在于：

> * 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。
> * 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。
> * 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。

但是，抽象工厂模式，也具有着不可避免的缺点：
> *  在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。

> * 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。

